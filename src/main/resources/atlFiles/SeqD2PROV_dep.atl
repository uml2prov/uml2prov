-- @path PROV=../../metamodels/prov.ecore
-- @nsURI UML=http://www.eclipse.org/uml2/5.0.0/UML


module SeqD2PROV;
create OUT: PROV from IN: UML;

--Example
--------------------------------------------------------------------------------------------------
---entity(var:input0, [prov:value = 'var:input0value'])      
---used(var:message, var:input0, -, [prov:role='u2p:seminar'])
	
---activity(var:message, [prov:type = 'u2p:includeAssociatedSeminar', 
						 ---tmpl:startTime = 'var:messageStartTime',
--- tmpl:endTime='var:messageEndTime' ])
---agent(var:lifeline, [prov:type='u2p:Seminar'])
---wasAssociatedWith(var:message, var:lifeline, - , [])
--------------------------------------------------------------------------------------------------

helper def: documentRoot: PROV!DocumentRoot =OclUndefined;
helper def: interaction: UML!Interaction =OclUndefined;

helper def : thereIsReply(msg: UML!Message) : Boolean = 
	UML!Message.allInstances()->exists(message | message.signature.name=msg.signature.name and message.messageSort.toString()='reply');



--Relationship: hadMember
--	entTOP - PROV!Entity which is a collection of Entities
--	ent - PROV!Entity which a member of entTOP Entity
--	doc - PROV!Document where hadMember relationship is added
rule genWDF(ent: String, entD: String, doc: PROV!Document){
	to
		e: PROV!IDRef (ref <- ent),
		ed: PROV!IDRef(ref<- entD),
		wdf: PROV!Derivation(usedEntity <- e,generatedEntity<- ed)
	do {
		doc.wasDerivedFrom <- wdf;
		thisModule.documentRoot.document<- doc;
	}
}

rule genWGBwithRole(ent: String, role: String, act: PROV!Activity, doc: PROV!Document){
	to
		e: PROV!IDRef (
			ref <- ent
		),
		a: PROV!IDRef (
			ref <- act.id
		),
		wgb: PROV!Generation (
			entity <- e,
			activity <- a,
			role <- role
		)
	do {
		doc.wasGeneratedBy <- wgb;
	}
}

--Element: Entity with type
rule genEntityWithTypeAndValue(p: String,t: String, v: String, doc: PROV!Document){
	to
		en: PROV!Entity (
			id <- p,
			type <- t,
			value <- v
		)
	do{
		
		doc.entity<-en;
	}
}

rule genInputParameter(entId: String, act: PROV!Activity, valueP: String,  doc:PROV!Document){
	to
		a: PROV!IDRef (
			ref <- act.id
		),
		e: PROV!IDRef (
			ref <- entId
		),
		u: PROV!Usage (
			activity <- a,
			entity <- e
		),
		ent: PROV!Entity (
			id <- entId,
			value <- valueP
		)
	do {
		doc.entity<- ent;
		doc.used <- u;
		thisModule.documentRoot.document<- doc;
	}
}

rule genOutputParameter(entId: String, act: PROV!Activity, valueP: String,  doc:PROV!Document){
	to
		a: PROV!IDRef (
			ref <- act.id
		),
		e: PROV!IDRef (
			ref <- entId
		),
		g: PROV!Generation (
			activity <- a,
			entity <- e
		),
		ent: PROV!Entity (
			id <- entId,
			value <- valueP
		)
	do {
		doc.entity<- ent;
		doc.wasGeneratedBy <- g;
		thisModule.documentRoot.document<- doc;
	}
}

rule associateInputOutput(outMsg: String , sendMessage: UML!Message, doc:PROV!Document){
	using {
		i: Integer = 0;
	}
	
	do {
			for (p in sendMessage.argument) {
				thisModule.genWDF('input' + i, outMsg, doc);
				i<-i + 1;
			}
			thisModule.documentRoot.document<- doc;
	}
}


rule setAgentType(ag: PROV!Agent, msg: UML!Message){
	do {
		for (lifeline in msg.interaction.lifeline) {
			for (cover in lifeline.coveredBy) {
				if (cover=msg.sendEvent) {
					ag.type<-lifeline.name;
				}
			}
		}
	}
}


rule setDocumentID(msg: UML!Message, doc: PROV!Document){
	do {
		doc.id<- msg.signature.owner.name+'_'+msg.signature.name;

	}
}

--Element: Entity with type
rule genEntity(p: String,t: String, doc: PROV!Document){
	to
		en: PROV!Entity (
			id <- p
		)
	do{
		doc.entity<-en;
		thisModule.addAttributeTo('prov:value', p + 'value', en);
	}
}

rule replyMessage(sendMessage: UML!Message, replyMessage: UML!Message,  ac: PROV!Activity, doc: PROV!Document){
	using {
		i: Integer = 0;
	}
	do {
			for (p in replyMessage.argument) {
				thisModule.genOutputParameter('output' + i, ac, 'output' + i + 'value', doc);
				thisModule.associateInputOutput('output' + i,sendMessage,doc);
				i<-i + 1;
			}

	}
}


rule searchReply(sendMessage: UML!Message, ac: PROV!Activity, doc:PROV!Document) {
	do {
		for (msg in sendMessage.interaction.message){
			if(msg.messageSort = #reply){
---				if(msg.signature.name = sendMessage.signature.name){
				if(msg.name = sendMessage.name){
					thisModule.replyMessage(sendMessage, msg, ac, doc);
				}
			}
		}
	}
}



entrypoint rule DocumentRoot(){
	to
		docR: PROV!DocumentRoot
	do {
		thisModule.documentRoot <- docR;
	}
}


--- Create / Destroy
rule createDestroy2document {
	from
		ms: UML!Message (
			ms.messageSort = #createMessage or ms.messageSort = #deleteMessage
		)
	using {
		i: Integer = 0;
	}
	to
		ac: PROV!Activity (
			id <- 'var:message',
			type <- 'exe:'+ms.signature.name
			--type <- ms.signature.name
		),
		acID: PROV!IDRef (
			ref <- 'var:message'
		),
		ag: PROV!Agent (
			id <- 'var:lifeline'
			--,type <- ms.interaction
		),
		agID: PROV!IDRef (
			ref <- 'var:lifeline'
		),
		ass: PROV!Association (
			activity <- acID,
			agent <- agID
		),
		doc: PROV!Document (
			activity <- ac,
			agent <- ag,
			wasAssociatedWith <- ass
		)
	do{
		
		thisModule.setAgentType(ag,ms);
				
		for (p in ms.argument) {
			thisModule.genInputParameter('var:input' + i, ac, 'input' + i + 'value', doc);
			i<-i + 1;
		}
		
		thisModule.setDocumentID(ms, doc);
		thisModule.documentRoot.document <- doc;
	}
}

--- SynchCall
rule synch2document {
	from
		ms: UML!Message ( ms.messageSort <> #createMessage and  ms.messageSort <> #deleteMessage)
	using {
		inParam: Boolean = false;
		outParam: Boolean = false;


	}
	to
		ac: PROV!Activity (
			id <- 'var:message',
			type<- 'exe:'+ms.signature.name
			--type <- ms.signature.name
		),
		acID: PROV!IDRef (
			ref <- 'var:message'
		),
		ag: PROV!Agent (
			id <- 'var:lifeline'
			--,type <- ms.interaction
		),
		agID: PROV!IDRef (
			ref <- 'var:lifeline'
		),
		ass: PROV!Association (
			activity <- acID,
			agent <- agID
		),
		doc: PROV!Document (
			activity <- ac,
			agent <- ag,
			wasAssociatedWith <- ass
		)
	do{
		
		for (p in ms.signature.ownedParameter) {
			if(p.direction.toString() = 'in'){
				thisModule.genInputParameter('var:input', ac, 'var:inputValue', doc);
				inParam = true;
			}
			if((p.direction.toString() = 'return' or p.direction.toString() = 'out') and thisModule.thereIsReply(ms)){			
					thisModule.genEntityWithTypeAndValue('var:output', 'var:outputType','var:outputValue', doc);
					thisModule.genWGBwithRole('var:output', 'exe:outputParameter', ac,doc);
					outParam=true;
			}
			if(inParam and outParam){
				thisModule.genWDF('var:input', 'var:output', doc);
			}
			
		}
		
		thisModule.setAgentType(ag,ms);
		thisModule.searchReply(ms, ac, doc);
		
		thisModule.setDocumentID(ms, doc);
		thisModule.documentRoot.document <- doc;
		
	}
}



--- AsynchCall
--rule asynch2document {
	--from
	--	ms: UML!Message (
	--		ms.messageSort = #asynchCall
	--	)
--	using {
--		i: Integer = 0;
--	}
--	to
--		ac: PROV!Activity (
--			id <- 'var:message',
--			type <- ms.name
--			--type <- ms.signature.name
--		),
--		acID: PROV!IDRef (
--			ref <- 'var:message'
--		),
--		ag: PROV!Agent (
--			id <- 'var:lifeline'
--			--,type <- ms.interaction
--		),
--		agID: PROV!IDRef (
--			ref <- 'var:lifeline'
--		),
--		ass: PROV!Association (
--			activity <- acID,
--			agent <- agID
--		),
--		doc: PROV!Document (
--			activity <- ac,
--			agent <- ag,
--			wasAssociatedWith <- ass
--		)
--	do{
--		
--		thisModule.setAgentType(ag,ms);
--		
--		for (p in ms.argument) {
--			thisModule.genInputParameter('input', ac, 'inputValue', doc);
--			i<-i + 1;
--		}
		
--		thisModule.setDocumentID(ms, doc);
--		thisModule.documentRoot.document <- doc;
--	}
--}


