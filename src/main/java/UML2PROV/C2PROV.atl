-- @nsURI UML=http://www.eclipse.org/uml2/5.0.0/UML
-- @path PROV=/ATLProject/metamodels/prov.ecore


module C2PROV;
create OUT: PROV from IN: UML;

--- Evaluates whether the context has the given stereotype or not.
helper context UML!Element def: hasStereotype(stereotype: String): Boolean =
	self.getAppliedStereotypes() -> collect(st | st.name) -> includes(stereotype);


helper context UML!Element def: getTagValue(stereotype: String, tagName : String) : String =
	if (self.hasStereotype(stereotype))  then
       self.getValue(self.getAppliedStereotypes().first(), 'item') --self.getValue(self.getAppliedStereotype(stereotype),tagName)
    else
       'noTagValue'
    endif;

helper def: documentRoot: PROV!DocumentRoot =
	OclUndefined;

---------------------------
---------------------------

--------------------------
----------------------------

-----------------------------
----------------------------

--Relationship: wasInvalidatedBy
--	ent - PROV!Entity invalidated by the Activity act
--	act - PROV!Activity which invalidates the Entity ent
--	doc - PROV!Document where WasInvalidatedBy relationship is added
rule genWIB(ent: String, act: PROV!Activity, doc: PROV!Document){
	to
		e: PROV!IDRef (
			ref <- ent
		),
		a: PROV!IDRef (
			ref <- act.id
		),
		wib: PROV!Invalidation (
			entity <- e,
			activity <- a
		)
	do {
		doc.wasInvalidatedBy <- wib;
	}
}

--Relationship: wasGeneratedBy
--	ent - PROV!Entity generated by the Activity act
--	act - PROV!Activity which generates the Entity ent
--	doc - PROV!Document where WasGeneratedBy relationship is added
rule genWGB(ent: String, act: PROV!Activity, doc: PROV!Document){
	to
		e: PROV!IDRef (
			ref <- ent
		),
		a: PROV!IDRef (
			ref <- act.id
		),
		wgb: PROV!Generation (
			entity <- e,
			activity <- a
		)
	do {
		doc.wasGeneratedBy <- wgb;
	}
}

rule genWGBwithRole(ent: String, role: String, act: PROV!Activity, doc: PROV!Document){
	to
		e: PROV!IDRef (
			ref <- ent
		),
		a: PROV!IDRef (
			ref <- act.id
		),
		wgb: PROV!Generation (
			entity <- e,
			activity <- a,
			role <- role
		)
	do {
		doc.wasGeneratedBy <- wgb;
	}
}

--Relationship: hadMember
--	entTOP - PROV!Entity which is a collection of Entities
--	ent - PROV!Entity which a member of entTOP Entity
--	doc - PROV!Document where hadMember relationship is added
rule hadMember(entTop: String, ent: String, doc: PROV!Document){
	to
		eTop: PROV!IDRef (
			ref <- entTop
		),
		e: PROV!IDRef (
			ref <- ent
		),
		hm: PROV!Membership (
			collection <- eTop,
			entity <- e
		)
	do {

		doc.hadMember <- hm;
	}
}

--Relationship: hadMember
--	entTOP - PROV!Entity which is a collection of Entities
--	ent - PROV!Entity which a member of entTOP Entity
--	doc - PROV!Document where hadMember relationship is added
rule hadMemberAttribute(entTop: String, ent: String, type: String, doc: PROV!Document){
	to
		eTop: PROV!IDRef (
			ref <- entTop
		),
		e: PROV!IDRef (
			ref <- ent
		),
		hm: PROV!Membership (
			collection <- eTop,
			entity <- e
		)
	do {
		--thisModule.addAttributeTo('prov:type', type, hm);
		doc.hadMember <- hm;
	}
}

--Relationship: hadMember
--	entTOP - PROV!Entity which is a collection of Entities
--	ent - PROV!Entity which a member of entTOP Entity
--	doc - PROV!Document where hadMember relationship is added
rule genWDF(ent: String, entD: String, doc: PROV!Document){
	to
		e: PROV!IDRef (
			ref <- ent
		),
		ed: PROV!IDRef (
			ref <- entD
		),
		wdf: PROV!Derivation (
			usedEntity <- e,
			generatedEntity <- ed
		)
	do {
		doc.wasDerivedFrom <- wdf;
	}
}
rule genWDF_quotation(ent: String, entD: String, doc: PROV!Document){
	to
		e: PROV!IDRef (
			ref <- ent
		),
		ed: PROV!IDRef (
			ref <- entD
		),
		wdf: PROV!Derivation (
			usedEntity <- e,
			generatedEntity <- ed
		)
	do {
		doc.wasDerivedFrom <- wdf;
	}
}
rule genWDF_structure(ent: String, entD: String, doc: PROV!Document){
	to
		e: PROV!IDRef (
			ref <- ent
		),
		ed: PROV!IDRef (
			ref <- entD
		),
		wdf: PROV!Derivation (
			usedEntity <- e,
			generatedEntity <- ed
		)
	do {
		doc.wasDerivedFrom <- wdf;
	}
}

rule genQuotationWDF(ent: String, entD: String, doc: PROV!Document){
	to
		e: PROV!IDRef (
			ref <- ent
		),
		ed: PROV!IDRef (
			ref <- entD
		),
		wdf: PROV!Quotation (
			usedEntity <- e,
			generatedEntity <- ed
		)
	do {
		doc.wasDerivedFrom <- wdf;
	}
}


--Relationship: Used
--	ent - PROV!Entity used by the Activity act
--	act - PROV!Activity which uses the Entity ent
--	doc - PROV!Document where Used relationship is added
---TODO: add role to know the name of the parameter
rule genU_parameter(en: String, ac: PROV!Activity, doc: PROV!Document){
	to
		e: PROV!IDRef (
			ref <- en
		),
		a: PROV!IDRef (
			ref <- ac.id
		),
		u: PROV!Usage (
			entity <- e,
			activity <- a
		)	
	do {
		doc.used<- u;
	}
}
rule genU_object(en: String, ac: PROV!Activity, doc: PROV!Document){
	to
		e: PROV!IDRef (
			ref <- en
		),
		a: PROV!IDRef (
			ref <- ac.id
		),
		u: PROV!Usage (
			entity <- e,
			activity <- a
		)	
	do {
		doc.used<- u;
	}
}

--Element: Entity
rule genEntity(p: String, doc: PROV!Document){
	to
		en: PROV!Entity (
			id <- p
		)
	do{
		doc.entity<-en;
		thisModule.addAttributeTo('prov:value', p + 'value', en);
	}
}


rule newAttributeEntity(doc: PROV!Document){
	to
		attName:  PROV!PAttribute (
			key <- 'u2p:attributeName', 
			value <- 'var:attName'
		),
		attClass:  PROV!PAttribute (
			key <- 'u2p:className', 
			value <- 'var:attType'
		),
		en: PROV!Entity (
			id <- 'var:attribute',
			type <- 'u2p:Attribute',
			value <- 'var:attValue',
			anyAttribute <- attName,
			anyAttribute <- attClass
		)
	do{
		doc.entity<-en;
	}
}

--Element: Entity with type
rule genEntityWithTypeAndValue(p: String,t: String, v: String, doc: PROV!Document){
	to
		class:  PROV!PAttribute (
			key <- 'u2p:className', 
			value <- t
		),
		en: PROV!Entity (
			id <- p,
			value <- v,
			anyAttribute <- class
		)
	do{
		
		doc.entity<-en;
	}
}

rule genObjectEntityWithTypeAndValue(p: String,t: String, v: String, doc: PROV!Document){
	to
		en: PROV!Entity (
			id <- p,
			type <- t,
			type<- 'u2p:Object',
			value <- v
		)
	do{
		
		doc.entity<-en;
	}
}


--Element: Entity with type
rule newInputEntity(doc:PROV!Document){
	to
		inputClass:  PROV!PAttribute (
			key <- 'u2p:className', 
			value <- 'var:inputType'
		),
	
		inputEn: PROV!Entity (
			id <- 'var:input',
			value <- 'var:inputValue',
			anyAttribute <- inputClass
		)
	do{
		doc.entity<-inputEn;
	}
}

rule addAttributeTo(key: String,value: String, element: OclAny){
	to
		attr: PROV!PAttribute (
			key <- key,
			value <- value
		)
	do{
		element.anyAttribute<- attr;
	}
}

rule addTypeTo(type:String , element: OclAny){
	do{
		element.type<- type;
	}
}


-------------------------
-----------------------------

--------------------------
-----------------------------

-----------------------------
entrypoint rule DocumentRoot() {
	to
		docR: PROV!DocumentRoot
		
	do {
			thisModule.documentRoot <- docR;
			
			for (cl in UML!Class.allInstances()) {
				---thisModule.initialStructure2Document(cl);
			}	
	}
}

------------------------------------ GENERAL  RULES
--- ---------------------------------------
---rule initialStructure2Document(cl: UML!Class) {
---	to
---		--enSS: PROV!Entity (id <- 'var:sourceState'),
---		enSS: PROV!Entity (
---			id <- 'var:target',
---			type <- 'exe:' + cl.name,
---			type <- 'exe:Object'
---		),
---		ac: PROV!Activity (
---			id <- 'var:operation',
---			type <- 'exe:new'
---		),
---		e: PROV!IDRef (
---			ref <- enSS.id
---		),
---		a: PROV!IDRef (
---			ref <- ac.id
---		),
---		gen: PROV!Generation(
---			activity <- a,
---			entity <- e
---		),
---		doc: PROV!Document (
---			id <- cl.name + '_sourceStructure',
---			entity <- enSS,
---			wasGeneratedBy <- gen,
---			activity <- ac
---		)
---		
---	do {			
---			if(cl.ownedAttribute.size() > 0){
---				thisModule.newAttributeEntity(doc);
---				--thisModule.genEntityWithTypeAndValue('var:attribute', 'var:attType','var:attValue', doc);
---				thisModule.hadMemberAttribute(enSS.id, 'var:attribute', 'exe:ownedAttribute', doc);
---				thisModule.addTypeTo('prov:Collection', enSS);
---			}
---						
			
			
---			thisModule.documentRoot.document<-doc;
---		}
---}

--From an Operation with the <<add>> stereotype
rule OperationAdd2DocumentRoot {
	from
		cl: UML!Operation (
			cl.hasStereotype('add')
		)
	using {
		i: Integer = 0;
		j: Integer = 0;
	}
	to
		--Elements
		---coll_old: PROV!Entity (
		----	id <- 'var:coll_old'
		---),
		coll_new: PROV!Entity (
			id <- 'var:coll_new',
			type <- 'var:coll_newType',
			type<- 'prov:Collection'
		),
		inp: PROV!Entity (
			id <- 'var:input',
			value <- 'var:inputValue'
		),
		rem: PROV!Entity (
			id <- 'var:collElements'
		),
		--remainder elements from coll1
		ac: PROV!Activity (
			id <- 'var:operation',
			type <- 'exe:'+cl.name
		),
		source_state: PROV!Entity (
			id <- 'var:source',
			type <- 'exe:' + cl.class.name,
			type<- 'u2p:Object'
		),
		target_state: PROV!Entity (
			id <- 'var:target',
			type <- 'exe:' + cl.class.name,
			type<-'u2p:Object'
		),
		doc: PROV!Document (
			id <- cl.class.name + '_' + cl.name,
			---entity <- coll_old,
			entity <- coll_new,
			entity <- inp,
			entity <- rem,
			activity <- ac,
			entity <- target_state,
			entity <- source_state
		)
	do {
			if(cl.class.ownedAttribute.size() > 1){
				thisModule.newAttributeEntity(doc);
				---thisModule.genEntityWithTypeAndValue('var:attribute', 'var:attType','var:attValue', doc);
				thisModule.hadMemberAttribute(target_state.id, 'var:attribute','', doc);	
				thisModule.addTypeTo('prov:Collection', source_state);
				thisModule.addTypeTo('prov:Collection', target_state);
			}
			
			thisModule.genWGB(target_state.id, ac, doc);
			thisModule.genWDF_structure(source_state.id, target_state.id, doc);
		

			thisModule.genU_parameter(inp.id, ac, doc);
			thisModule.genU_object(source_state.id, ac, doc);
			
			thisModule.genWGB(coll_new.id, ac, doc);
			---thisModule.genWDF(inp.id, coll_new.id, doc);
			
			thisModule.hadMember(target_state.id, coll_new.id, doc);	
			thisModule.hadMember(coll_new.id, 'var:collElements', doc);	
			thisModule.hadMember(coll_new.id, 'var:input', doc);	

			
			--attributes
			--thisModule.addAttributeTo('prov:type', 'var:object', target_state);
			thisModule.documentRoot.document<-doc;		

		}
}




--From an Operation with the <<remove>> stereotype
rule OperationModify2DocumentRoot {
from
		cl: UML!Operation (
			cl.hasStereotype('modify')
		)
	using {
		i: Integer = 0;
		j: Integer = 0;
	}
	to
		--Elements
		---coll_old: PROV!Entity (
		----	id <- 'var:coll_old'
		---),
		
		att:  PROV!PAttribute (
			key <- 'u2p:attributeName', 
			value <- 'var:newAttrName'
		),
		
		coll_new: PROV!Entity (
			id <- 'var:newAttr',
			type <- 'u2p:Attribute',
			value <- 'var:newAttrValue',
			anyAttribute <- att
		),
		inp: PROV!Entity (
			id <- 'var:input',
			value <- 'var:inputValue'
		),
		--rem: PROV!Entity (
		--	id <- 'var:oldAttr'
		--),
		--remainder elements from coll1
		ac: PROV!Activity (
			id <- 'var:operation',
			type <- 'exe:'+cl.name
		),
		source_state: PROV!Entity (
			id <- 'var:source',
			type <- 'exe:' + cl.class.name,
			type<- 'exe:Object'
		),
		target_state: PROV!Entity (
			id <- 'var:target',
			type <- 'exe:' + cl.class.name,
			type<-'exe:Object'
		),
		doc: PROV!Document (
			id <- cl.class.name + '_' + cl.name,
			---entity <- coll_old,
			entity <- coll_new,
			entity <- inp,
			--entity <- rem,
			activity <- ac,
			entity <- target_state,
			entity <- source_state
		)
	do {
			if(cl.class.ownedAttribute.size() > 1){
				thisModule.newAttributeEntity(doc);
				
				---thisModule.genEntityWithTypeAndValue('var:attribute', 'var:attType','var:attValue', doc);
				thisModule.hadMemberAttribute(target_state.id, 'var:attribute','', doc);	
				thisModule.addTypeTo('prov:Collection', source_state);
				thisModule.addTypeTo('prov:Collection', target_state);
			}
			
			thisModule.genWGB(target_state.id, ac, doc);
			thisModule.genWDF_structure(source_state.id, target_state.id, doc);
		

			thisModule.genU_parameter(inp.id, ac, doc);
			thisModule.genU_object(source_state.id, ac, doc);
			
			thisModule.genWGB(coll_new.id, ac, doc);
			---thisModule.genWDF(inp.id, coll_new.id, doc);
			
			thisModule.hadMember(target_state.id, coll_new.id, doc);	
			--thisModule.genWDF('var:oldAttr',coll_new.id, doc);	

			
			--attributes
		--thisModule.addAttributeTo('prov:type', 'var:object', target_state);
		thisModule.documentRoot.document<-doc;		
			

		}
}















--From an Operation with the <<remove>> stereotype
rule OperationRemove2DocumentRoot {
from
		cl: UML!Operation (
			cl.hasStereotype('remove')
		)
	using {
		i: Integer = 0;
		j: Integer = 0;
	}
	to
		--Elements
		---coll_old: PROV!Entity (
		----	id <- 'var:coll_old'
		---),
		coll_new: PROV!Entity (
			id <- 'var:coll_new',
			type <- 'var:coll_newType',
			type<- 'prov:Collection'
		),
		inp: PROV!Entity (
			id <- 'var:input',
			value <- 'var:inputValue'
		),
		rem: PROV!Entity (
			id <- 'var:collElements'
		),
		--remainder elements from coll1
		ac: PROV!Activity (
			id <- 'var:operation',
			type <- 'exe:'+cl.name
		),
		source_state: PROV!Entity (
			id <- 'var:source',
			type <- 'exe:' + cl.class.name,
			type<- 'exe:Object'
		),
		target_state: PROV!Entity (
			id <- 'var:target',
			type <- 'exe:' + cl.class.name,
			type<-'exe:Object'
		),
		doc: PROV!Document (
			id <- cl.class.name + '_' + cl.name,
			---entity <- coll_old,
			entity <- coll_new,
			entity <- inp,
			entity <- rem,
			activity <- ac,
			entity <- target_state,
			entity <- source_state
		)
	do {
			if(cl.class.ownedAttribute.size() > 1){
				thisModule.newAttributeEntity(doc);
				---thisModule.genEntityWithTypeAndValue('var:attribute', 'var:attType','var:attValue', doc);
				thisModule.hadMemberAttribute(target_state.id, 'var:attribute','', doc);	
				thisModule.addTypeTo('prov:Collection', source_state);
				thisModule.addTypeTo('prov:Collection', target_state);
			}
			
			thisModule.genWGB(target_state.id, ac, doc);
			thisModule.genWDF_structure(source_state.id, target_state.id, doc);
		

			thisModule.genU_parameter(inp.id, ac, doc);
			thisModule.genU_object(source_state.id, ac, doc);
			
			thisModule.genWGB(coll_new.id, ac, doc);
			---thisModule.genWDF(inp.id, coll_new.id, doc);
			
			thisModule.hadMember(target_state.id, coll_new.id, doc);	
			thisModule.hadMember(coll_new.id, 'var:collElements', doc);	

			
			--attributes
		--thisModule.addAttributeTo('prov:type', 'var:object', target_state);
		thisModule.documentRoot.document<-doc;		
			

		}
}


--From an Operation with the <<setter>> stereotype
rule OperationSetter2Document {
	from
		cl: UML!Operation (
			cl.hasStereotype('set')
		)
	using {
		isIN: Boolean = false;
		i: Integer = 0;
		j: Integer = 0;
		attr: PROV!PAttribute = PROV!PAttribute;
		attributes: Sequence(PROV!PAttribute) = Sequence{};
	}
	to
		--Elements 
		--enSA: PROV!Entity (id <- 'var:sourceAttribute'),
		--enSS: PROV!Entity (id <- 'var:sourceState'),
		enSS: PROV!Entity (
			id <- 'var:source',
			type <- 'exe:' + cl.class.name,
			type<-'exe:Object'
		),
		enTS: PROV!Entity (
			id <- 'var:target',
			type <- 'exe:' + cl.class.name,
			type<-'exe:Object'
		),
		ac: PROV!Activity (
			id <- 'var:operation'
		),
		doc: PROV!Document (
			id <- cl.class.name + '_' + cl.name,
			activity <- ac,
			entity <- enSS,
			entity <- enTS			
		)
	do {
			  --thisModule.genWIB(enSA.id,ac,doc);
		thisModule.genU_object(enSS.id, ac, doc);
			thisModule.genWGB(enTS.id, ac, doc);
			--thisModule.genWGB(enTA.id, ac, doc);
			  --thisModule.hadMember(enSS.id, enSA.id, doc);
		

		thisModule.genWDF_structure(enSS.id, enTS.id, doc);			
			
			  --generate all the input parameters entities
			for (p in cl.ownedParameter) {
				if(not isIN and p.direction.toString() = 'in'){
						thisModule.genEntityWithTypeAndValue('var:input','var:inputType', 'var:inputValue', doc);
						thisModule.genU_parameter('var:input', ac,doc);
						thisModule.hadMember(enTS.id, 'var:input', doc);	
						isIN<-true;
				}
			}		
			
			if(cl.class.ownedAttribute.size() > 1){
				thisModule.newAttributeEntity(doc);
				---thisModule.genEntityWithTypeAndValue('var:attribute', 'var:attType','var:attValue', doc);
				thisModule.hadMemberAttribute(enTS.id, 'var:attribute','', doc);	
				thisModule.addTypeTo('prov:Collection', enTS);
				thisModule.addTypeTo('prov:Collection', enSS);
			}
			
			thisModule.documentRoot.document<-doc;
		}
}


--From an Operation with the <<setter>> stereotype
rule OperationCommand2Document {
	from
		cl: UML!Operation (
			cl.hasStereotype('command')
		)
	using {
		i: Integer = 0;
		j: Integer = 0;
		existIn: Boolean = false;
		attr: PROV!PAttribute = PROV!PAttribute;
		attributes: Sequence(PROV!PAttribute) = Sequence{};
	}
	to
		--Elements 
		--enSS: PROV!Entity (id <- 'var:sourceState'),
		enSS: PROV!Entity (
			id <- 'var:source',
			type <- 'exe:' + cl.class.name,
			type<- 'prov:Object',
			type<- 'prov:Collection'
		),
		enTS: PROV!Entity (
			id <- 'var:target',
			type <- 'exe:' + cl.class.name,
			type<- 'prov:Object',
			type<- 'prov:Collection'
		),
		ac: PROV!Activity (
			id <- 'var:operation'
		),
		doc: PROV!Document (
			id <- cl.class.name + '_' + cl.name,
			activity <- ac,
			entity <- enSS,
			entity <- enTS
		)
	do {
			  --thisModule.genWIB(enSA.id,ac,doc);
		thisModule.genU_object(enSS.id, ac, doc);
		thisModule.genWGB(enTS.id, ac, doc);
			  --thisModule.hadMember(enSS.id, enSA.id, doc);
		thisModule.genWDF_structure(enSS.id, enTS.id, doc);

			  --generate all the input parameters entities
			for (ip in cl.ownedParameter) {
				if(not existIn and ip.direction.toString() = 'in'){
						thisModule.genEntityWithTypeAndValue('var:input','var:inputType', 'var:inputValue', doc);
						thisModule.genU_parameter('var:input', ac,doc);
					--thisModule.genWDF('var:input', enTS.id, doc);
					existIn <- true;
					
				}else if(ip.direction.toString() = 'out' or ip.direction.toString()='return'){
					--thisModule.genEntityWithTypeAndValue('var:input','var:inputType', 'var:inputValue', doc);
					--thisModule.genU_parameter('var:input', ac,doc);
					thisModule.genEntity('var:messageReply', doc);
					thisModule.genEntity('var:output', doc);
					thisModule.genWGB('var:messageReply', ac, doc);
					thisModule.hadMemberAttribute('var:messageReply', 'var:output', '', doc);	
					if(existIn){
						thisModule.genWDF('var:input', 'var:messageReply', doc);
					}
				}
			}			
			
			if(cl.class.ownedAttribute.size() > 1){
				thisModule.newAttributeEntity(doc);
				---thisModule.genEntityWithTypeAndValue('var:attribute', 'var:attType','var:attValue', doc);
				thisModule.hadMemberAttribute(enTS.id, 'var:attribute', '', doc);	
			}
			thisModule.documentRoot.document<-doc;
		}
}

--From an Operation with the <<getter>> stereotype
--una idea es meter el property y el void-accessor aqui dentro y poner condicion, es un unico elemento lo que se aniade
rule OperationGetter2Document {
	from
		cl: UML!Operation (
			cl.hasStereotype('get') or 
			cl.hasStereotype('search')	or
			cl.hasStereotype('predicate') 
		)
	using {
		isIN: Boolean = false;
		isOUT: Boolean = false;

	}
	to
		--Elements 
		--enSA: PROV!Entity (id <- 'var:sourceAttribute'),
		enTA: PROV!Entity (
			id <- 'var:messageReply',
			type <- 'u2p:MessageReply'
		),
		--enSS: PROV!Entity (id <- 'var:sourceState'),
		enSS: PROV!Entity (
			id <- 'var:source',
			type <- 'exe:' + cl.class.name,
			type<- 'u2p:Object',
			type<- 'prov:Collection'
		),
		ac: PROV!Activity (
			id <- 'var:operation'
		),	
		doc: PROV!Document (
			id <- cl.class.name + '_' + cl.name,
			activity <- ac,
			entity <- enSS,
			entity <- enTA --entity <- enSS		
		)
	do {
		--thisModule.genWIB(enSA.id,ac,doc);
		thisModule.genU_object(enSS.id, ac, doc);
		thisModule.genWGB(enTA.id, ac, doc);
		
		
		for (p in cl.ownedParameter) {
			if(not isIN and p.direction.toString() = 'in'){
					thisModule.genEntityWithTypeAndValue('var:input','var:inputType', 'var:inputValue', doc);
					thisModule.genU_parameter('var:input', ac,	doc);
					thisModule.genWDF('var:input', 'var:messageReply', doc);
					isIN<-true;
			}
			
			if(not isOUT and (p.direction.toString() = 'return' or p.direction.toString() = 'out')){
				thisModule.genEntityWithTypeAndValue('var:output', 'var:outputType','var:outputValue', doc);
				thisModule.hadMember(enTA.id, 'var:output', doc);
				isOUT<-true;
				
				if(not cl.getTagValue('predicate','item').equals('noTagValue')){
					thisModule.genEntity('var:targetAttribute', doc);
					thisModule.genWDF('var:targetAttribute', 'output', doc);
				}
			}
		}
		
		thisModule.documentRoot.document<-doc;
	}
}

--From an Operation with the <<getter>> stereotype
rule OperationPredicate2Document {
	from
		cl: UML!Operation (
			cl.hasStereotype('predicateeee_never')
		)
	using {
		i: Integer = 0;
		j: Integer = 0;
		attr: PROV!PAttribute = PROV!PAttribute;
		attributes: Sequence(PROV!PAttribute) = Sequence{};
	}
	to
		--Elements 
		--enSA: PROV!Entity (id <- 'var:sourceAttribute'),
		enTA: PROV!Entity (
			id <- 'var:messageReply',
			type <- 'u2p:MessageReply'
		),
		--enSS: PROV!Entity (id <- 'var:sourceState'),
		enSS: PROV!Entity (
			id <- 'var:source',
			type <- 'exe:' + cl.class.name,
			type<- 'exe:Object',
			type<- 'prov:Collection'
		),
		out: PROV!Entity (
			id <- 'var:output',
			type <- 'var:outputType',
			value <- 'var:outputValue'
		),
		ac: PROV!Activity (
			id <- 'var:operation'
		),
		doc: PROV!Document (
			id <- cl.class.name + '_' + cl.name,
			activity <- ac,
			entity <- enSS,
			entity <- out,
			entity <- enTA --entity <- enSS		
		)
		
	do {
			  --thisModule.genWIB(enSA.id,ac,doc);
		thisModule.genU_object(enSS.id, ac, doc);
		thisModule.genWGB(enTA.id, ac, doc);
		thisModule.hadMember(enTA.id, out.id, doc);
		--thisModule.genWDF(enAtt.id, enTA.id, doc);
			
		thisModule.documentRoot.document<-doc;
		}
}


--From an Operation with the <<getter>> stereotype
rule OperationProperty2Document {
from
		cl: UML!Operation (
			cl.hasStereotype('property') or 
			cl.hasStereotype('void-accessor')
		)
	using {
		isIN: Boolean = false;
		isOUT: Boolean = false;

	}
	to
		enTargAtt: PROV!Entity (
			id <- 'var:targetAttribute'
		),
		--Elements 
		--enSA: PROV!Entity (id <- 'var:sourceAttribute'),
		enTA: PROV!Entity (
			id <- 'var:messageReply',
			type <- 'exe:MessageReply'
		),
		--enSS: PROV!Entity (id <- 'var:sourceState'),
		enSS: PROV!Entity (
			id <- 'var:source',
			type <- 'exe:' + cl.class.name,
			type<- 'exe:Object',
			type<- 'prov:Collection'
		),
		ac: PROV!Activity (
			id <- 'var:operation'
		),	
		doc: PROV!Document (
			id <- cl.class.name + '_' + cl.name,
			activity <- ac,
			entity <- enSS,
			entity <- enTA, --entity <- enSS
			entity <- enTargAtt
		)
	do {
			  --thisModule.genWIB(enSA.id,ac,doc);
		thisModule.genU_object(enSS.id, ac, doc);
		thisModule.genWGB(enTA.id, ac, doc);
		
		
		for (p in cl.ownedParameter) {
			if(not isIN and p.direction.toString() = 'in'){
					thisModule.genEntityWithTypeAndValue('var:input','var:inputType', 'var:inputValue', doc);
					thisModule.genU_parameter('var:input', ac,	doc);
					thisModule.genWDF('var:input', 'var:messageReply', doc);
					
					isIN<-true;
			}
			
			if(not isOUT and (p.direction.toString() = 'return' or p.direction.toString() = 'out')){
				thisModule.genEntityWithTypeAndValue('var:output', 'var:outputType','var:outputValue', doc);
				thisModule.hadMember(enTA.id, 'var:output', doc);
				thisModule.genWDF('var:targetAttribute', 'var:output', doc);
				
				isOUT<-true;
			}
		}

			
		thisModule.documentRoot.document<-doc;
		}	
}


rule OperationCreate2Document {
	from
		operation: UML!Operation (operation.hasStereotype('Create')) 
	using {
		existIn: Boolean=operation.ownedParameter->
			exists(ip|ip.direction.toString()='in');
		hasAttr: Boolean=operation.class.ownedAttribute->size() > 1;
	}
	to
		targetEn: PROV!Entity (
			id <- 'var:target',
			type <- 'exe:' + operation.class.name,
			type<- 'u2p:Object'
		),
		operationAct: PROV!Activity (
			id <- 'var:operation'
		),
		wgb: PROV!Generation (
			entity <- targetID,
			activity <- activityID
		),	
		targetID: PROV!IDRef (
			ref <- targetEn.id
		),
		activityID: PROV!IDRef (
			ref <- operationAct.id
		),
		
		doc: PROV!Document (
			id <- operation.class.name + '_new',
			activity <- operationAct,
			entity <- targetEn,
			wasGeneratedBy<-wgb
		)
		
	do {	
			--generate all the input parameters entities
			if(existIn){
		 
				 --genU_parameter
				thisModule.genEntityWithTypeAndValue('var:input','var:inputType', 'var:inputValue', doc);
				thisModule.genU_parameter('var:input', operationAct,	doc);
				---thisModule.generateUsageRelationship('var:input', operationAct, doc);
				 
				 --generateWDFRelationship
				thisModule.genWDF('var:input', targetEn.id, doc);
			}
			
			if(hasAttr){
				--genEntityWithTypeAndValue
				thisModule.newAttributeEntity(doc);
				
				--hadMemberAttribute
				thisModule.hadMemberAttribute(targetEn.id, 'var:attribute', '', doc);	
			}
			
			thisModule.documentRoot.document<-doc;
		}
	}

rule OperationCreate22Document {
	from
		operation: UML!Operation (operation.getAppliedStereotypes().isEmpty() and operation.class.name = operation.name) 
	using {
		existIn: Boolean=operation.ownedParameter->
			exists(ip|ip.direction.toString()='in');
		hasAttr: Boolean=operation.class.ownedAttribute->size() > 1;
	}
	to
		targetEn: PROV!Entity (
			id <- 'var:target',
			type <- 'exe:' + operation.class.name,
			type<- 'u2p:Object'
		),
		operationAct: PROV!Activity (
			id <- 'var:operation'
		),
		wgb: PROV!Generation (
			entity <- targetID,
			activity <- activityID
		),	
		targetID: PROV!IDRef (
			ref <- targetEn.id
		),
		activityID: PROV!IDRef (
			ref <- operationAct.id
		),
		
		doc: PROV!Document (
			id <- operation.class.name + '_new',
			activity <- operationAct,
			entity <- targetEn,
			wasGeneratedBy<-wgb
		)
		
	do {	
			--generate all the input parameters entities
			if(existIn){
		 
				 --genU_parameter
				thisModule.genEntityWithTypeAndValue('var:input','var:inputType', 'var:inputValue', doc);
				thisModule.genU_parameter('var:input', operationAct,	doc);
				---thisModule.generateUsageRelationship('var:input', operationAct, doc);
				 
				 --generateWDFRelationship
				thisModule.genWDF('var:input', targetEn.id, doc);
			}
			
			if(hasAttr){
				--genEntityWithTypeAndValue
				thisModule.newAttributeEntity(doc);
				
				--hadMemberAttribute
				thisModule.hadMemberAttribute(targetEn.id, 'var:attribute', '', doc);	
			}
			
			thisModule.documentRoot.document<-doc;
		}
	}



--From an Operation without any stereotype
--	Each one of the input parameters will be an entity identified as inputParamN, where
-- N is the position in the argument list
--Each one of the Entity input parameters is related to the Activity through used
-- relationship
--  Each one of the output parameters will be an entity identified as outputParamN, where
-- N is the position in the argument list
--Each one of the Entity output parameters is related to the Activity through
-- wasGeneratedBy relationship
--Each one of the Entity output parameters is related to the Entity input parameters by
-- means of the wasDerivedFrom relationship
rule Operation2Document {
 	from
 		cl: UML!Operation (
 			cl.getAppliedStereotypes().isEmpty() and cl.class.name <> cl.name
 					--and not cl.name.startsWith('set') 
 					--and	not cl.name.startsWith('remove') 
 					--and not cl.name.startsWith('add')
 					 --and not cl.name.startsWith(cl.class.name) 
 					--and not cl.name.startsWith('get')
 					--and not cl.name.startsWith('serach')
 					--and not cl.name.startsWith('modify')
 					--and not cl.name.startsWith('Create')
					--and not cl.name.startsWith('predicate')
					--and not cl.name.startsWith('command')
					--and not cl.name.startsWith('property')
					--and not cl.name.startsWith('void-accessor')
 		)
 	using {
 		isIN: Boolean = false;
 		isOUT: Boolean = false;
 		return_i: Integer = 0;
 		j: Integer = 0;
 	}
 	to
	    ac: PROV!Activity (
 			id <- 'var:operation'
 		),
 		en: PROV!Entity (
 			id <- 'var:source',
 			type<-'exe:Object',
			type <- 'exe:' + cl.class.name
 		),
 		doc: PROV!Document (
 			activity <- ac,
 			entity <- en, 
			id <- cl.class.name + '_' + cl.name
 		)
 	do {
 			--thisModule.addAttributeTo('prov:type', 'var:attType', attr);
 			--thisModule.hadMember(en.id, attr.id, doc);
 			thisModule.genU_object(en.id, ac, doc);
			
 			for (p in cl.ownedParameter) {
 				if(not isIN and p.direction.toString() = 'in'){
						thisModule.genEntityWithTypeAndValue('var:input','var:inputType', 'var:inputValue', doc);
						thisModule.genU_parameter('var:input', ac,doc);
 						isIN<-true;
 				}
				
 				if(not isOUT and (p.direction.toString() = 'return' or p.direction.toString() = 'out')){
 					thisModule.genEntityWithTypeAndValue('var:output', 'var:outputType','var:outputValue', doc);
 					thisModule.genWGBwithRole('var:output', 'exe:outputParameter', ac,doc);
 					isOUT<-true;
 				}

 			}
 			if(isIN and isOUT){
 				thisModule.genWDF('var:input', 'var:output', doc);
 			}
			
		
 			if(cl.class.ownedAttribute.size() > 0){
 				thisModule.addTypeTo('prov:Collection', en);
 			}
 			
 	
 			thisModule.documentRoot.document<-doc;
 	}
 }

